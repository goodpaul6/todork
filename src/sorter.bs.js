// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_list from "rescript/lib/es6/js_list.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";

function indentLevel(line) {
  var _curLevel = 0;
  var _line = line;
  while(true) {
    var line$1 = _line;
    var curLevel = _curLevel;
    if (line$1.startsWith("    ")) {
      _line = line$1.substring(4);
      _curLevel = curLevel + 1 | 0;
      continue ;
    }
    if (!line$1.startsWith("\t")) {
      return curLevel;
    }
    _line = line$1.substring(1);
    _curLevel = curLevel + 1 | 0;
    continue ;
  };
}

function parseElements(lines) {
  var parseChildrenRec = function (_accElements, parentIndentLevel, _lines) {
    while(true) {
      var lines = _lines;
      var accElements = _accElements;
      if (!lines) {
        return [
                accElements,
                lines
              ];
      }
      var line = lines.hd;
      var lineIndentLevel = indentLevel(line);
      if (lineIndentLevel <= parentIndentLevel) {
        return [
                accElements,
                lines
              ];
      }
      var match = parseChildrenRec(/* [] */0, lineIndentLevel, lines.tl);
      var newAcc_0 = {
        line: line,
        children: Js_list.rev(match[0])
      };
      var newAcc = {
        hd: newAcc_0,
        tl: accElements
      };
      _lines = match[1];
      _accElements = newAcc;
      continue ;
    };
  };
  var match = parseChildrenRec(/* [] */0, -1, lines);
  return Js_list.rev(match[0]);
}

var taskRe = /\s*[-\*]\s+\[(.?)\]/;

function parseTaskIsCompleted(line) {
  var resOpt = taskRe.exec(line);
  return Belt_Option.map(Belt_Option.flatMap(resOpt === null ? undefined : Caml_option.some(resOpt), (function (res) {
                    return Caml_option.nullable_to_opt(Caml_array.get(res, 1));
                  })), (function (s) {
                return s !== " ";
              }));
}

function compareElements(a, b) {
  var aCompletedTask = parseTaskIsCompleted(a.line);
  var bCompletedTask = parseTaskIsCompleted(b.line);
  if (aCompletedTask !== undefined) {
    if (bCompletedTask !== undefined) {
      if (aCompletedTask) {
        if (bCompletedTask) {
          return 0;
        } else {
          return -1;
        }
      } else if (bCompletedTask) {
        return 1;
      } else {
        return 0;
      }
    } else if (b.line.trim() === "") {
      return 0;
    } else {
      return 1;
    }
  } else if (bCompletedTask !== undefined && a.line.trim() !== "") {
    return -1;
  } else {
    return 0;
  }
}

function sortElements(elements) {
  var elemsWithSortedChildren = Belt_List.map(elements, (function (elem) {
          return {
                  line: elem.line,
                  children: sortElements(elem.children)
                };
        }));
  var elementsArr = Belt_List.toArray(elemsWithSortedChildren);
  Belt_SortArray.stableSortInPlaceBy(elementsArr, compareElements);
  return Belt_List.fromArray(elementsArr);
}

function elementsToLines(elements) {
  var elementsToLinesRec = function (_accLines, _elements) {
    while(true) {
      var elements = _elements;
      var accLines = _accLines;
      if (!elements) {
        return accLines;
      }
      var element = elements.hd;
      var accLinesWithChildren = elementsToLinesRec({
            hd: element.line,
            tl: accLines
          }, element.children);
      _elements = elements.tl;
      _accLines = accLinesWithChildren;
      continue ;
    };
  };
  return Js_list.rev(elementsToLinesRec(/* [] */0, elements));
}

function sortLines(lines) {
  var linesList = Belt_List.fromArray(lines);
  var elements = parseElements(linesList);
  var sortedElements = sortElements(elements);
  return Belt_List.toArray(elementsToLines(sortedElements));
}

export {
  indentLevel ,
  parseElements ,
  taskRe ,
  parseTaskIsCompleted ,
  compareElements ,
  sortElements ,
  elementsToLines ,
  sortLines ,
}
/* No side effect */
